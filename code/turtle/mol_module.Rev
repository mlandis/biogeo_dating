############
# settings #
############

n_mol_states   <- 4
n_mol_elements <- n_mol_states*(n_mol_states-1)/2


########
# data #
########

d_mol = readDiscreteCharacterData(mol_fn)
n_parts = d_mol.size()


################
# Branch-rates #
################

# constrain variance of distribution of relaxed clocks
ucln_sd ~ dnExp(0.1)
ucln_sd.setValue(0.1)
mv[mvi++] = mvScale(ucln_sd, lambda=0.2, weight=20.0)
mv[mvi++] = mvScale(ucln_sd, lambda=0.1, weight=20.0)
mv[mvi++] = mvScale(ucln_sd, lambda=1., weight=10.0)
ucln_mean := ln( clock_mol ) - ucln_sd*ucln_sd*0.5

# branch rates draw from a discretized Lognormal (k=32)
rate_distribution = dnLnorm(mean=ucln_mean, sd=ucln_sd)
num_rate_categories <- 32
rate_categories := fnDiscretizeDistribution(rate_distribution, num_rate_categories)
rate_probs <- simplex(rep(1,num_rate_categories))
step_size = round(num_rate_categories/8)

# assign branch rate vector
for (i in 1:floor(n_branches)) {
    br_mol_clock[i] ~ dnMixture(rate_categories, rate_probs)
    mv[mvi++] = mvMixtureAllocation(br_mol_clock[i], weight=1., delta=step_size)
}

#############
# DNA model #
#############

# exchangeability rates
er_mol_pr <- rep(1.,n_mol_elements)
er_mol_1 ~ dnDirichlet(er_mol_pr)
er_mol_2 ~ dnDirichlet(er_mol_pr)
er_mol_3 ~ dnDirichlet(er_mol_pr)
er_mol_1.setValue(simplex(rep(1.,6)))
er_mol_2.setValue(simplex(rep(1.,6)))
er_mol_3.setValue(simplex(rep(1.,6)))
mv[mvi++] = mvSimplexElementScale(x=er_mol_1, alpha=30.0, tune=true, weight=20.0)
mv[mvi++] = mvSimplexElementScale(x=er_mol_2, alpha=30.0, tune=true, weight=20.0)
mv[mvi++] = mvSimplexElementScale(x=er_mol_3, alpha=30.0, tune=true, weight=20.0)

# base frequencies
bf_mol_pr <- rep(1.,n_mol_states)
bf_mol_1 ~ dnDirichlet(bf_mol_pr)
bf_mol_2 ~ dnDirichlet(bf_mol_pr)
bf_mol_3 ~ dnDirichlet(bf_mol_pr)
bf_mol_1.setValue(simplex(rep(1.,4)))
bf_mol_2.setValue(simplex(rep(1.,4)))
bf_mol_3.setValue(simplex(rep(1.,4)))
mv[mvi++] = mvSimplexElementScale(x=bf_mol_1, alpha=30.0, tune=true, weight=10.0)
mv[mvi++] = mvSimplexElementScale(x=bf_mol_2, alpha=30.0, tune=true, weight=10.0)
mv[mvi++] = mvSimplexElementScale(x=bf_mol_3, alpha=30.0, tune=true, weight=10.0)

# rate matrices
rm_mol_1 := fnGTR(exchangeRates=er_mol_1, baseFrequencies=bf_mol_1)
rm_mol_2 := fnGTR(exchangeRates=er_mol_2, baseFrequencies=bf_mol_2)
rm_mol_3 := fnGTR(exchangeRates=er_mol_3, baseFrequencies=bf_mol_3)

# site-heterogeneity, +Gamma4
alpha_mol_gr ~ dnUnif(0, 50)
alpha_mol_gr.setValue(1.)
site_mol_clock := fnDiscretizeGamma(alpha_mol_gr, alpha_mol_gr, 4, false)
mv[mvi++] = mvScale(alpha_mol_gr, tune=true, weight=25)

# CTMC
for (i in 1:3) {
    n_mol_sites[i] <- d_mol[i].nchar()
}
m_mol_1 ~ dnPhyloCTMC(tree=tau,Q=rm_mol_1,rootFrequencies=bf_mol_1,branchRates=br_mol_clock,siteRates=site_mol_clock,nSites=n_mol_sites[1],type="DNA")
m_mol_2 ~ dnPhyloCTMC(tree=tau,Q=rm_mol_2,rootFrequencies=bf_mol_2,branchRates=br_mol_clock,siteRates=site_mol_clock,nSites=n_mol_sites[2],type="DNA")
m_mol_3 ~ dnPhyloCTMC(tree=tau,Q=rm_mol_3,rootFrequencies=bf_mol_3,branchRates=br_mol_clock,siteRates=site_mol_clock,nSites=n_mol_sites[3],type="DNA")
m_mol_1.clamp(d_mol[1])
m_mol_2.clamp(d_mol[2])
m_mol_3.clamp(d_mol[3])

